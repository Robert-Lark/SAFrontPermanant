webpackHotUpdate_N_E("pages/_app",{

/***/ "./lib/paginationFields.js":
/*!*********************************!*\
  !*** ./lib/paginationFields.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return paginationField; });\n/* harmony import */ var _components_Pagination__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Pagination */ \"./components/Pagination.js\");\n// //This page allows you to remove items from the cache without messing up the pagination\n// import {PAGINATION_QUERY} from \"../components/Pagination\";\n// export default function paginationField() {\n//   return {\n//     keyArgs: false, //tells Apollo we will take care of everything\n//     read(existing = [], {args, cache}) {\n//       const {skip, first} = args;\n//       //read the number of items on the page from the cache\n//       const data = cache.readQuery({query: PAGINATION_QUERY});\n//       //how many products are there?\n//       const count = data?._allProductsMeta?.count;\n//       //what page are we on?\n//       const page = skip / first + 1;\n//       //how many pages are there?\n//       const pages = Math.ceil(count / first);\n//       //check if we have existing items\n//       //filter out for undefined items\n//       const items = existing.slice(skip, skip + first).filter((x) => x);\n//       if (items.length && items.length !== first && page == pages) {\n//         //if there are items & there arent enough items to satisfy how many we are requesting to show per page\n//         //and we are on the last page\n//         //then just send it anyway\n//         return items;\n//       }\n//       if (items.length !== first) {\n//         //we dont have any items and must go to the network to fetch them\n//         return false;\n//       }\n//       //if there are items return them from the cache\n//       if (items.length) {\n//         return items;\n//       }\n//       return false; // fallback to network if either if statements dont run\n//     },\n//     merge(existing, incoming, {args}) {\n//       const {skip, first} = args;\n//       //This runs when Apollo client comes back from the network with our products\n//       // you can then define how they are added to the cache\n//       const merged = existing ? existing.slice(0) : [];\n//       for (let i = skip; i < skip + incoming.length; ++i) {\n//         merged[i] = incoming[i - skip];\n//       }\n//       return merged;\n//     },\n//   };\n// }\n\nfunction paginationField() {\n  return {\n    keyArgs: false,\n    // tells apollo we will take care of everything\n    read: function read() {\n      var _data$_allProductsMet;\n\n      var existing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var _ref = arguments.length > 1 ? arguments[1] : undefined,\n          args = _ref.args,\n          cache = _ref.cache;\n\n      // console.log({ existing, args, cache });\n      var skip = args.skip,\n          first = args.first; // Read the number of items on the page from the cache\n\n      var data = cache.readQuery({\n        query: _components_Pagination__WEBPACK_IMPORTED_MODULE_0__[\"PAGINATION_QUERY\"]\n      });\n      var count = data === null || data === void 0 ? void 0 : (_data$_allProductsMet = data._allProductsMeta) === null || _data$_allProductsMet === void 0 ? void 0 : _data$_allProductsMet.count;\n      var page = skip / first + 1;\n      var pages = Math.ceil(count / first); // Check if we have existing items\n\n      var items = existing.slice(skip, skip + first).filter(function (x) {\n        return x;\n      }); // If\n      // There are items\n      // AND there aren't enough items to satisfy how many were requested\n      // AND we are on the last page\n      // THEN JUST SEND IT\n\n      if (items.length && items.length !== first && page === pages) {\n        return items;\n      }\n\n      if (items.length !== first) {\n        // We don't have any items, we must go to the network to fetch them\n        return false;\n      } // If there are items, just reutrn them from the cache, and we don't need to go to the network\n\n\n      if (items.length) {\n        // console.log(\n        //   `There are ${items.length} items in the cache! Gonna send them to apollo`\n        // );\n        return items;\n      }\n\n      return false; // fallback to network\n      // First thing it does it asks the read function for those items.\n      // We can either do one of two things:\n      // First things we can do is return the items because they are already in the cache\n      // The other thing we can do is to return false from here, (network request)\n    },\n    merge: function merge(existing, incoming, _ref2) {\n      var args = _ref2.args;\n      var skip = args.skip,\n          first = args.first; // This runs when the Apollo client comes back from the network with our product\n\n      var merged = existing ? existing.slice(0) : [];\n\n      for (var i = skip; i < skip + incoming.length; ++i) {\n        merged[i] = incoming[i - skip];\n      } // Finally we return the merged items from the cache,\n\n\n      return merged;\n    }\n  };\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3BhZ2luYXRpb25GaWVsZHMuanM/ZjNmMyJdLCJuYW1lcyI6WyJwYWdpbmF0aW9uRmllbGQiLCJrZXlBcmdzIiwicmVhZCIsImV4aXN0aW5nIiwiYXJncyIsImNhY2hlIiwic2tpcCIsImZpcnN0IiwiZGF0YSIsInJlYWRRdWVyeSIsInF1ZXJ5IiwiUEFHSU5BVElPTl9RVUVSWSIsImNvdW50IiwiX2FsbFByb2R1Y3RzTWV0YSIsInBhZ2UiLCJwYWdlcyIsIk1hdGgiLCJjZWlsIiwiaXRlbXMiLCJzbGljZSIsImZpbHRlciIsIngiLCJsZW5ndGgiLCJtZXJnZSIsImluY29taW5nIiwibWVyZ2VkIiwiaSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVlLFNBQVNBLGVBQVQsR0FBMkI7QUFDeEMsU0FBTztBQUNMQyxXQUFPLEVBQUUsS0FESjtBQUNXO0FBQ2hCQyxRQUZLLGtCQUVnQztBQUFBOztBQUFBLFVBQWhDQyxRQUFnQyx1RUFBckIsRUFBcUI7O0FBQUE7QUFBQSxVQUFmQyxJQUFlLFFBQWZBLElBQWU7QUFBQSxVQUFUQyxLQUFTLFFBQVRBLEtBQVM7O0FBQ25DO0FBRG1DLFVBRTNCQyxJQUYyQixHQUVYRixJQUZXLENBRTNCRSxJQUYyQjtBQUFBLFVBRXJCQyxLQUZxQixHQUVYSCxJQUZXLENBRXJCRyxLQUZxQixFQUluQzs7QUFDQSxVQUFNQyxJQUFJLEdBQUdILEtBQUssQ0FBQ0ksU0FBTixDQUFnQjtBQUFFQyxhQUFLLEVBQUVDLHVFQUFnQkE7QUFBekIsT0FBaEIsQ0FBYjtBQUNBLFVBQU1DLEtBQUssR0FBR0osSUFBSCxhQUFHQSxJQUFILGdEQUFHQSxJQUFJLENBQUVLLGdCQUFULDBEQUFHLHNCQUF3QkQsS0FBdEM7QUFDQSxVQUFNRSxJQUFJLEdBQUdSLElBQUksR0FBR0MsS0FBUCxHQUFlLENBQTVCO0FBQ0EsVUFBTVEsS0FBSyxHQUFHQyxJQUFJLENBQUNDLElBQUwsQ0FBVUwsS0FBSyxHQUFHTCxLQUFsQixDQUFkLENBUm1DLENBVW5DOztBQUNBLFVBQU1XLEtBQUssR0FBR2YsUUFBUSxDQUFDZ0IsS0FBVCxDQUFlYixJQUFmLEVBQXFCQSxJQUFJLEdBQUdDLEtBQTVCLEVBQW1DYSxNQUFuQyxDQUEwQyxVQUFDQyxDQUFEO0FBQUEsZUFBT0EsQ0FBUDtBQUFBLE9BQTFDLENBQWQsQ0FYbUMsQ0FZbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFJSCxLQUFLLENBQUNJLE1BQU4sSUFBZ0JKLEtBQUssQ0FBQ0ksTUFBTixLQUFpQmYsS0FBakMsSUFBMENPLElBQUksS0FBS0MsS0FBdkQsRUFBOEQ7QUFDNUQsZUFBT0csS0FBUDtBQUNEOztBQUNELFVBQUlBLEtBQUssQ0FBQ0ksTUFBTixLQUFpQmYsS0FBckIsRUFBNEI7QUFDMUI7QUFDQSxlQUFPLEtBQVA7QUFDRCxPQXhCa0MsQ0EwQm5DOzs7QUFDQSxVQUFJVyxLQUFLLENBQUNJLE1BQVYsRUFBa0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZUFBT0osS0FBUDtBQUNEOztBQUVELGFBQU8sS0FBUCxDQWxDbUMsQ0FrQ3JCO0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDRCxLQTFDSTtBQTJDTEssU0EzQ0ssaUJBMkNDcEIsUUEzQ0QsRUEyQ1dxQixRQTNDWCxTQTJDK0I7QUFBQSxVQUFScEIsSUFBUSxTQUFSQSxJQUFRO0FBQUEsVUFDMUJFLElBRDBCLEdBQ1ZGLElBRFUsQ0FDMUJFLElBRDBCO0FBQUEsVUFDcEJDLEtBRG9CLEdBQ1ZILElBRFUsQ0FDcEJHLEtBRG9CLEVBRWxDOztBQUVBLFVBQU1rQixNQUFNLEdBQUd0QixRQUFRLEdBQUdBLFFBQVEsQ0FBQ2dCLEtBQVQsQ0FBZSxDQUFmLENBQUgsR0FBdUIsRUFBOUM7O0FBQ0EsV0FBSyxJQUFJTyxDQUFDLEdBQUdwQixJQUFiLEVBQW1Cb0IsQ0FBQyxHQUFHcEIsSUFBSSxHQUFHa0IsUUFBUSxDQUFDRixNQUF2QyxFQUErQyxFQUFFSSxDQUFqRCxFQUFvRDtBQUNsREQsY0FBTSxDQUFDQyxDQUFELENBQU4sR0FBWUYsUUFBUSxDQUFDRSxDQUFDLEdBQUdwQixJQUFMLENBQXBCO0FBQ0QsT0FQaUMsQ0FTbEM7OztBQUNBLGFBQU9tQixNQUFQO0FBQ0Q7QUF0REksR0FBUDtBQXdERCIsImZpbGUiOiIuL2xpYi9wYWdpbmF0aW9uRmllbGRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLy9UaGlzIHBhZ2UgYWxsb3dzIHlvdSB0byByZW1vdmUgaXRlbXMgZnJvbSB0aGUgY2FjaGUgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBwYWdpbmF0aW9uXG5cbi8vIGltcG9ydCB7UEFHSU5BVElPTl9RVUVSWX0gZnJvbSBcIi4uL2NvbXBvbmVudHMvUGFnaW5hdGlvblwiO1xuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYWdpbmF0aW9uRmllbGQoKSB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAga2V5QXJnczogZmFsc2UsIC8vdGVsbHMgQXBvbGxvIHdlIHdpbGwgdGFrZSBjYXJlIG9mIGV2ZXJ5dGhpbmdcblxuLy8gICAgIHJlYWQoZXhpc3RpbmcgPSBbXSwge2FyZ3MsIGNhY2hlfSkge1xuLy8gICAgICAgY29uc3Qge3NraXAsIGZpcnN0fSA9IGFyZ3M7XG5cbi8vICAgICAgIC8vcmVhZCB0aGUgbnVtYmVyIG9mIGl0ZW1zIG9uIHRoZSBwYWdlIGZyb20gdGhlIGNhY2hlXG4vLyAgICAgICBjb25zdCBkYXRhID0gY2FjaGUucmVhZFF1ZXJ5KHtxdWVyeTogUEFHSU5BVElPTl9RVUVSWX0pO1xuLy8gICAgICAgLy9ob3cgbWFueSBwcm9kdWN0cyBhcmUgdGhlcmU/XG4vLyAgICAgICBjb25zdCBjb3VudCA9IGRhdGE/Ll9hbGxQcm9kdWN0c01ldGE/LmNvdW50O1xuLy8gICAgICAgLy93aGF0IHBhZ2UgYXJlIHdlIG9uP1xuLy8gICAgICAgY29uc3QgcGFnZSA9IHNraXAgLyBmaXJzdCArIDE7XG4vLyAgICAgICAvL2hvdyBtYW55IHBhZ2VzIGFyZSB0aGVyZT9cbi8vICAgICAgIGNvbnN0IHBhZ2VzID0gTWF0aC5jZWlsKGNvdW50IC8gZmlyc3QpO1xuXG4vLyAgICAgICAvL2NoZWNrIGlmIHdlIGhhdmUgZXhpc3RpbmcgaXRlbXNcbi8vICAgICAgIC8vZmlsdGVyIG91dCBmb3IgdW5kZWZpbmVkIGl0ZW1zXG4vLyAgICAgICBjb25zdCBpdGVtcyA9IGV4aXN0aW5nLnNsaWNlKHNraXAsIHNraXAgKyBmaXJzdCkuZmlsdGVyKCh4KSA9PiB4KTtcblxuLy8gICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAmJiBpdGVtcy5sZW5ndGggIT09IGZpcnN0ICYmIHBhZ2UgPT0gcGFnZXMpIHtcbi8vICAgICAgICAgLy9pZiB0aGVyZSBhcmUgaXRlbXMgJiB0aGVyZSBhcmVudCBlbm91Z2ggaXRlbXMgdG8gc2F0aXNmeSBob3cgbWFueSB3ZSBhcmUgcmVxdWVzdGluZyB0byBzaG93IHBlciBwYWdlXG4vLyAgICAgICAgIC8vYW5kIHdlIGFyZSBvbiB0aGUgbGFzdCBwYWdlXG4vLyAgICAgICAgIC8vdGhlbiBqdXN0IHNlbmQgaXQgYW55d2F5XG4vLyAgICAgICAgIHJldHVybiBpdGVtcztcbi8vICAgICAgIH1cbi8vICAgICAgIGlmIChpdGVtcy5sZW5ndGggIT09IGZpcnN0KSB7XG4vLyAgICAgICAgIC8vd2UgZG9udCBoYXZlIGFueSBpdGVtcyBhbmQgbXVzdCBnbyB0byB0aGUgbmV0d29yayB0byBmZXRjaCB0aGVtXG4vLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgIH1cbi8vICAgICAgIC8vaWYgdGhlcmUgYXJlIGl0ZW1zIHJldHVybiB0aGVtIGZyb20gdGhlIGNhY2hlXG4vLyAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4vLyAgICAgICAgIHJldHVybiBpdGVtcztcbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsbGJhY2sgdG8gbmV0d29yayBpZiBlaXRoZXIgaWYgc3RhdGVtZW50cyBkb250IHJ1blxuLy8gICAgIH0sXG4vLyAgICAgbWVyZ2UoZXhpc3RpbmcsIGluY29taW5nLCB7YXJnc30pIHtcbi8vICAgICAgIGNvbnN0IHtza2lwLCBmaXJzdH0gPSBhcmdzO1xuLy8gICAgICAgLy9UaGlzIHJ1bnMgd2hlbiBBcG9sbG8gY2xpZW50IGNvbWVzIGJhY2sgZnJvbSB0aGUgbmV0d29yayB3aXRoIG91ciBwcm9kdWN0c1xuLy8gICAgICAgLy8geW91IGNhbiB0aGVuIGRlZmluZSBob3cgdGhleSBhcmUgYWRkZWQgdG8gdGhlIGNhY2hlXG4vLyAgICAgICBjb25zdCBtZXJnZWQgPSBleGlzdGluZyA/IGV4aXN0aW5nLnNsaWNlKDApIDogW107XG4vLyAgICAgICBmb3IgKGxldCBpID0gc2tpcDsgaSA8IHNraXAgKyBpbmNvbWluZy5sZW5ndGg7ICsraSkge1xuLy8gICAgICAgICBtZXJnZWRbaV0gPSBpbmNvbWluZ1tpIC0gc2tpcF07XG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gbWVyZ2VkO1xuLy8gICAgIH0sXG4vLyAgIH07XG4vLyB9XG5cblxuaW1wb3J0IHsgUEFHSU5BVElPTl9RVUVSWSB9IGZyb20gJy4uL2NvbXBvbmVudHMvUGFnaW5hdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhZ2luYXRpb25GaWVsZCgpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXlBcmdzOiBmYWxzZSwgLy8gdGVsbHMgYXBvbGxvIHdlIHdpbGwgdGFrZSBjYXJlIG9mIGV2ZXJ5dGhpbmdcbiAgICByZWFkKGV4aXN0aW5nID0gW10sIHsgYXJncywgY2FjaGUgfSkge1xuICAgICAgLy8gY29uc29sZS5sb2coeyBleGlzdGluZywgYXJncywgY2FjaGUgfSk7XG4gICAgICBjb25zdCB7IHNraXAsIGZpcnN0IH0gPSBhcmdzO1xuXG4gICAgICAvLyBSZWFkIHRoZSBudW1iZXIgb2YgaXRlbXMgb24gdGhlIHBhZ2UgZnJvbSB0aGUgY2FjaGVcbiAgICAgIGNvbnN0IGRhdGEgPSBjYWNoZS5yZWFkUXVlcnkoeyBxdWVyeTogUEFHSU5BVElPTl9RVUVSWSB9KTtcbiAgICAgIGNvbnN0IGNvdW50ID0gZGF0YT8uX2FsbFByb2R1Y3RzTWV0YT8uY291bnQ7XG4gICAgICBjb25zdCBwYWdlID0gc2tpcCAvIGZpcnN0ICsgMTtcbiAgICAgIGNvbnN0IHBhZ2VzID0gTWF0aC5jZWlsKGNvdW50IC8gZmlyc3QpO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGV4aXN0aW5nIGl0ZW1zXG4gICAgICBjb25zdCBpdGVtcyA9IGV4aXN0aW5nLnNsaWNlKHNraXAsIHNraXAgKyBmaXJzdCkuZmlsdGVyKCh4KSA9PiB4KTtcbiAgICAgIC8vIElmXG4gICAgICAvLyBUaGVyZSBhcmUgaXRlbXNcbiAgICAgIC8vIEFORCB0aGVyZSBhcmVuJ3QgZW5vdWdoIGl0ZW1zIHRvIHNhdGlzZnkgaG93IG1hbnkgd2VyZSByZXF1ZXN0ZWRcbiAgICAgIC8vIEFORCB3ZSBhcmUgb24gdGhlIGxhc3QgcGFnZVxuICAgICAgLy8gVEhFTiBKVVNUIFNFTkQgSVRcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAmJiBpdGVtcy5sZW5ndGggIT09IGZpcnN0ICYmIHBhZ2UgPT09IHBhZ2VzKSB7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggIT09IGZpcnN0KSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IGl0ZW1zLCB3ZSBtdXN0IGdvIHRvIHRoZSBuZXR3b3JrIHRvIGZldGNoIHRoZW1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgaXRlbXMsIGp1c3QgcmV1dHJuIHRoZW0gZnJvbSB0aGUgY2FjaGUsIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGdvIHRvIHRoZSBuZXR3b3JrXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFxuICAgICAgICAvLyAgIGBUaGVyZSBhcmUgJHtpdGVtcy5sZW5ndGh9IGl0ZW1zIGluIHRoZSBjYWNoZSEgR29ubmEgc2VuZCB0aGVtIHRvIGFwb2xsb2BcbiAgICAgICAgLy8gKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGZhbGxiYWNrIHRvIG5ldHdvcmtcblxuICAgICAgLy8gRmlyc3QgdGhpbmcgaXQgZG9lcyBpdCBhc2tzIHRoZSByZWFkIGZ1bmN0aW9uIGZvciB0aG9zZSBpdGVtcy5cbiAgICAgIC8vIFdlIGNhbiBlaXRoZXIgZG8gb25lIG9mIHR3byB0aGluZ3M6XG4gICAgICAvLyBGaXJzdCB0aGluZ3Mgd2UgY2FuIGRvIGlzIHJldHVybiB0aGUgaXRlbXMgYmVjYXVzZSB0aGV5IGFyZSBhbHJlYWR5IGluIHRoZSBjYWNoZVxuICAgICAgLy8gVGhlIG90aGVyIHRoaW5nIHdlIGNhbiBkbyBpcyB0byByZXR1cm4gZmFsc2UgZnJvbSBoZXJlLCAobmV0d29yayByZXF1ZXN0KVxuICAgIH0sXG4gICAgbWVyZ2UoZXhpc3RpbmcsIGluY29taW5nLCB7IGFyZ3MgfSkge1xuICAgICAgY29uc3QgeyBza2lwLCBmaXJzdCB9ID0gYXJncztcbiAgICAgIC8vIFRoaXMgcnVucyB3aGVuIHRoZSBBcG9sbG8gY2xpZW50IGNvbWVzIGJhY2sgZnJvbSB0aGUgbmV0d29yayB3aXRoIG91ciBwcm9kdWN0XG5cbiAgICAgIGNvbnN0IG1lcmdlZCA9IGV4aXN0aW5nID8gZXhpc3Rpbmcuc2xpY2UoMCkgOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSBza2lwOyBpIDwgc2tpcCArIGluY29taW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1lcmdlZFtpXSA9IGluY29taW5nW2kgLSBza2lwXTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWxseSB3ZSByZXR1cm4gdGhlIG1lcmdlZCBpdGVtcyBmcm9tIHRoZSBjYWNoZSxcbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcbiAgfTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/paginationFields.js\n");

/***/ })

})